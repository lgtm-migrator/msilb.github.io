---
layout: post
title: Writing a Scala and Akka-HTTP based client for REST API
comments: true
---

And so I decided to write another HTTP Client using Scala. Sounds easy? Sure, if you know where to start. As with so many things in the Scala world, picking your libraries can be the hardest part. In this post I'll try to make the experience of writing a HTTP client library in Scala a little less painful so you don't have to start from scratch. Ok, enough introduction, let's start!

In my particular use case I wanted to develop a type-safe HTTP client library for consuming Oanda REST API v20. You can have a look at the [API spec](http://developer.oanda.com/rest-live-v20/introduction) if you want to learn more about specific protocol but here we want to focus on getting the right tools to get the job done.

First, we need an HTTP client library that we can use with Scala. There are plenty of good options for Java like the de-facto standard [Apache HTTP Client](http://hc.apache.org/httpcomponents-client-5.0.x/index.html) or its async [sibling](https://hc.apache.org/httpcomponents-asyncclient-4.1.x/index.html), [Async HTTP Client](https://github.com/AsyncHttpClient/async-http-client), [HTTP Client from Google](https://github.com/google/google-http-java-client) and many other solid choices. And certainly, Scala being a JVM language can make use of any of those. But as a Scala developer, one is always trying to find a good 'idiomatic' Scala library first before resorting to other options. And this is not always easy. Unfortunately, my conclusion after spending quite some time researching for alternatives in this space is that most libraries are immature, or are not maintained any more, or both.

I used [spray](http://spray.io) in the past and was more or less happy with it. However, it is not maintained now and users are directed to migrate to [Akka HTTP](http://doc.akka.io/docs/akka-http/current/scala.html) which is an official rewrite of spray. Initially, I was a bit hesitant to bring in Akka HTTP into my project. After all, I didn't really need any of the server-side functionality, which seems to be the main focus of Akka HTTP, with client capabilities being treated more or less as a stepchild. After a quick 'google' I found few alternatives and decided to [dispatch](https://github.com/dispatch/reboot) a try. It was being praised as one of the most mature HTTP client libraries in Scala which is both easy to get started with and has a beautiful idiomatic Scala API. So far so good! It worked fine for basic GET/PUT/PATCH/POST requests. But then I had to do some more sophisticated stuff like processing responses with chunked transfer encoding I hit the road block. It's not that I didn't try to make it work. But it turned out to be overly complicated and I didn't want to spend a lot of time 'hacking in' basic HTTP functionality when I had a real task at hand. This is unfortunately, often a common theme among Scala libraries that either don't come from Lightbend itself or have a [Typelevel](http://typelevel.org) label attached to it. 'Hello World' use cases are working fine out of the box, however if you need more advanced functionality be prepared to roll up your sleeves and spend countless hours trying to fix basic stuff using limited resources available on StackOverflow and others.

Long story short, eventually I had to abandon dispatch and went back to using Akka HTTP, which was at least mature enough, but more importantly, has the largest community behind it and is being actively maintained. My only piece of advice here for anyone who is starting a new project that requires HTTP client capabilities, don't waste your time experimenting with different Scala libraries and just pick the one that works, for me it is undoubtfully Akka HTTP.

Next challenge: picking a JSON library. Again, plenty of alternatives there and I haven't tried most of them. I used [spray-json](https://github.com/spray/spray-json) in the past, however the amount of boilerplate required to make it work was not ideal. Then I discovered [circe](https://github.com/circe/circe) boasting fully automatic derivation for encoding/decoding your domain model (`case class`es and `case object`s) into/from JSON. In the simplest scenario all you need to do is provide one import where you want to use en-/decoding:

```scala
import io.circe.generic.auto._
```

The rest is magically taken care of by Scala macros generating implicit instances of `Encoder` and `Decoder` objects. Looks good on paper, BUT: macros are not the most stable part of the Scala compiler (as we'll see in a second) and it will slow down your compilation by A LOT (at one point my [project](https://github.com/msilb/scalanda-v20) took 12 minutes to compile). Now, one particular issue I encountered when using fully automatic derivation is that circe is using [shapeless](https://github.com/milessabin/shapeless) under the hood to derive `Encoder` and `Decoder` instances, which in turn relies on Scala macros. This foundation seems to be not very rock solid though. Things like [this](https://issues.scala-lang.org/browse/SI-7046), [this](https://issues.scala-lang.org/browse/SI-7567) and [this](https://github.com/lloydmeta/enumeratum/issues/90) do not fill one with confidence. In fact, I encountered the same error as the author of the last linked github issue: `knownDirectSubclasses observed before subclass registered` and it just seemed completely random depending on in which file my case classes were defined and similar things. Only switching to a more reliable semi-automatic derivation using `Codec` annotation finally stabilized the build. However, the build still takes about 3-4 minutes to complete. I am thinking about abandoning `shapeless` backed derivation altogether and using more manual ways to define my `Encoder`s and `Decoder`s in order to speed up the compilation. This however, will bring back the boilerplate. Tradeoffs, it's always about tradeoffs.

TBC...
